"""Calculation job plugin for OLCAO.

This module implements the AiiDA CalcJob for running OLCAO calculations.
The workflow consists of two steps:
1. makeinput - prepares input files from skeleton
2. uolcao - runs the actual DFT calculation
"""

from __future__ import annotations

from aiida import orm
from aiida.common import CalcInfo, CodeInfo
from aiida.engine import CalcJob
from aiida.orm import AbstractCode

from .data.data import DEFAULTS, OlcaoParameters

# Files to always retrieve
COMMON_RETRIEVE = [
    "gs_*-*.out",  # Main output with energies
    "gs_enrg-*.dat",  # Energy convergence
    "gs_iter-*.dat",  # Iteration data
    "summary",  # Calculation summary
    "runtime",  # Timing information
    "olcao.dat",  # Main control file (generated by makeinput)
    "structure.dat",  # Atomic positions
]

# Calculation-specific output files
CALC_TYPE_RETRIEVE = {
    "scf": [],
    "dos": [
        "gs_dos-*.t.plot",  # Total DOS
        "gs_dos-*.p.raw",  # Partial DOS raw data
        "gs_dos-*.loci.plot",  # Local DOS
    ],
    "bond": [
        "gs_bond-*.raw",  # Bond order data
    ],
    "sybd": [
        "gs_sybd-*.plot",  # Band structure
        "vdim-*.raw",  # Band dimensions
    ],
    "optc": [
        "gs_optc-*.t.plot",  # Optical properties
        "gs_optc-*.t.eps1.plot",  # Epsilon 1
        "gs_optc-*.t.eps2.plot",  # Epsilon 2
        "gs_optc-*.t.cond.plot",  # Conductivity
    ],
    "pacs": [
        "gs_pacs-*.plot",  # XANES spectrum
    ],
    "field": [
        "gs_field-*.plot",  # Field data
    ],
    "force": [
        "gs_force-*.dat",  # Force data
    ],
    "nlop": [
        "gs_nlop-*.plot",  # Nonlinear optical
    ],
    "sige": [
        "gs_sige-*.plot",  # Sigma(E)
    ],
    "loen": [
        "gs_loen-*.dat",  # Local environment
    ],
}

# OLCAO environment setup template
# This is prepended to the job script before running uolcao
PREPEND_TEMPLATE = """# OLCAO environment setup
source {olcao_rc}
export OLCAO_TEMP="$(pwd)/olcao_scratch"
mkdir -p "$OLCAO_TEMP"

# Run makeinput to prepare input files
{makeinput_path} {makeinput_args}

# Check if makeinput succeeded
if [ ! -d "inputs" ]; then
    echo "ERROR: makeinput failed - no inputs/ directory created" >&2
    exit 1
fi
"""


class OlcaoCalculation(CalcJob):
    """AiiDA CalcJob plugin to run OLCAO calculations.

    This CalcJob handles the two-step OLCAO workflow:
    1. Run makeinput to prepare input files from skeleton
    2. Run uolcao to perform the actual calculation

    The skeleton file is automatically staged as 'olcao.skl' (required by makeinput).
    Environment variables are set to keep all files within AiiDA's working directory.
    """

    # Default paths for Hellbender - can be overridden via inputs
    DEFAULT_OLCAO_RC = "/home/dd9wn/olcao/.olcao/olcaorc"
    DEFAULT_MAKEINPUT_PATH = "/home/dd9wn/olcao/bin/makeinput"

    @classmethod
    def define(cls, spec):
        super().define(spec)

        # --- Inputs ---
        spec.input(
            "code",
            valid_type=AbstractCode,
            help="The uolcao executable as an AiiDA Code.",
        )
        spec.input(
            "skeleton",
            valid_type=orm.SinglefileData,
            help="The OLCAO skeleton file (.skl). Will be staged as 'olcao.skl'.",
        )
        spec.input(
            "parameters",
            valid_type=OlcaoParameters,
            required=True,
            help="OLCAO parameters (kpoints, calculation_type, basis, edge).",
        )

        # --- OLCAO-specific options ---
        spec.input(
            "olcao_rc",
            valid_type=orm.Str,
            required=False,
            default=lambda: orm.Str(cls.DEFAULT_OLCAO_RC),
            help="Path to olcaorc file on remote. Default: /home/dd9wn/olcao/.olcao/olcaorc",
        )
        spec.input(
            "makeinput_path",
            valid_type=orm.Str,
            required=False,
            default=lambda: orm.Str(cls.DEFAULT_MAKEINPUT_PATH),
            help="Path to makeinput executable on remote. Default: /home/dd9wn/olcao/bin/makeinput",
        )

        # --- Parser ---
        spec.input("metadata.options.parser_name", valid_type=str, default="olcao")

        # --- REQUIRED for CalcJob validation ---
        spec.input(
            "metadata.options.resources",
            valid_type=dict,
            default={"num_machines": 1, "num_mpiprocs_per_machine": 1},
            help="Scheduler resources. Defaults to 1 machine, 1 MPI proc.",
        )
        spec.input(
            "metadata.options.max_wallclock_seconds",
            valid_type=int,
            default=3600,
            help="Maximum wallclock time in seconds.",
        )

        # --- Scheduler stdout/stderr ---
        spec.input("metadata.options.scheduler_stdout", valid_type=str, default="_scheduler-stdout.txt")
        spec.input("metadata.options.scheduler_stderr", valid_type=str, default="_scheduler-stderr.txt")

        # --- Optional: retrieve HDF5 checkpoint files (large) ---
        spec.input(
            "retrieve_hdf5",
            valid_type=orm.Bool,
            required=False,
            default=lambda: orm.Bool(False),
            help="If True, also retrieve HDF5 checkpoint files (can be large).",
        )

        # --- Outputs ---
        spec.output(
            "output_parameters",
            valid_type=orm.Dict,
            help="Parsed results extracted from OLCAO output files.",
        )

        # --- Exit codes ---
        spec.exit_code(300, "ERROR_NO_RETRIEVED_FOLDER", message="No retrieved folder found.")
        spec.exit_code(301, "ERROR_MISSING_OUTPUT_FILE", message="Required output file not found.")
        spec.exit_code(302, "ERROR_NOT_CONVERGED", message="SCF calculation did not converge.")
        spec.exit_code(303, "ERROR_SCF_FAILED", message="SCF calculation failed.")
        spec.exit_code(310, "ERROR_MAKEINPUT_FAILED", message="makeinput failed - no inputs/ directory.")

    def prepare_for_submission(self, folder):
        """Create input files and instructions to run OLCAO.

        Steps:
        1. Stage skeleton file as 'olcao.skl' (required by makeinput)
        2. Generate prepend_text to set up environment and run makeinput
        3. Configure uolcao to run with appropriate arguments
        4. Set up retrieval of output files based on calculation type
        """
        # Stage the skeleton file as 'olcao.skl' (REQUIRED exact name)
        with self.inputs.skeleton.open(mode="rb") as handle:
            folder.create_file_from_filelike(handle, "olcao.skl")

        # Get parameters and generate command lines
        parameters = self.inputs.parameters
        makeinput_args = parameters.get_makeinput_cmdline()
        uolcao_args = parameters.get_uolcao_cmdline()

        # Get OLCAO paths
        olcao_rc = self.inputs.olcao_rc.value
        makeinput_path = self.inputs.makeinput_path.value

        # Generate prepend text for environment setup and makeinput
        prepend_text = PREPEND_TEMPLATE.format(
            olcao_rc=olcao_rc,
            makeinput_path=makeinput_path,
            makeinput_args=makeinput_args,
        )

        # Set up the uolcao code execution
        codeinfo = CodeInfo()
        codeinfo.code_uuid = self.inputs.code.uuid
        # Split uolcao_args into list for cmdline_params
        codeinfo.cmdline_params = uolcao_args.split()

        calcinfo = CalcInfo()
        calcinfo.codes_info = [codeinfo]
        calcinfo.prepend_text = prepend_text

        # Build retrieve list based on calculation type
        retrieve_list = self._build_retrieve_list()
        calcinfo.retrieve_list = retrieve_list

        return calcinfo

    def _build_retrieve_list(self) -> list:
        """Build the list of files to retrieve based on calculation type.

        Returns
        -------
        list
            List of file patterns to retrieve from the remote.
        """
        params = self.inputs.parameters.get_dict()
        calc_type = params.get("calculation_type", DEFAULTS["calculation_type"])

        # Start with common files
        retrieve_list = list(COMMON_RETRIEVE)

        # Add calculation-specific files
        if calc_type in CALC_TYPE_RETRIEVE:
            retrieve_list.extend(CALC_TYPE_RETRIEVE[calc_type])

        # Optionally add HDF5 files
        if self.inputs.retrieve_hdf5.value:
            retrieve_list.extend(
                [
                    "gs_scf-*.hdf5",
                    "gs_pscf-*.hdf5",
                ]
            )

        # Add scheduler output
        scheduler_stdout = self.node.get_option("scheduler_stdout") or "_scheduler-stdout.txt"
        scheduler_stderr = self.node.get_option("scheduler_stderr") or "_scheduler-stderr.txt"
        retrieve_list.extend([scheduler_stdout, scheduler_stderr])

        return retrieve_list
